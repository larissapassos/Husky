--- Tutorial ----

functionalibrary::filter

Prototype
----------
template<typename Cont, typename Predicate>
Cont filter(const Cont& data, Predicate good)

Definition
----------

The filter function removes the elements in a container by a given predicate.  A new container is returned with the filtered elements leaving the original container untouched.

Parameters
----------
container
Call any std container that uses forward iterators.

pred
Unary function that accepts an element in the range as argument, and returns a value convertible to bool. The value returned indicates whether the element is to be removed (if true, it is removed).
The function shall not modify its argument.  This can either be a function pointer or a function object.


Return value
------------

A new container is returned with the filtered elements leaving the original container untouched.

Tutorial
--------

1) Define a supported container that uses forward iterators (e.g. std::vector, std::list).
2) Call functionalibrary::filter with the specified arguments, remembering to pass in a predicate function

 

#include <iostream>          
#include <algorithm> 
#include <functional>
#include <vector>
#include <list>
#include <iterator>


bool isOdd (int i) { return ((i%2)==1); }

using namespace functionalibrary;

int main () {
  
  std::vector<int> taste{ 1, 2, 3, 4, 5, 6, 7, 8, 9};


  std::cout << filter(taste, isOdd);
  std::cout << filter(taste,[](int value){ return value > 4;});

  return 0;
}

Output:
13579
56789

Complexity
----------

Linear in the distance between first and last iterators.

Data Races
----------

The elements in the range [first,last) are accessed (each element is accessed exactly once).

Error Handling
--------------
Throws if any of pred, the element assignments or the operations on iterators throws.
Note that invalid arguments cause undefined behavior.

*****************************************************************************************************************


functionalibrary::compose

Prototype
----------

template<typename F, typename G>
decltype(auto)compose(F&& f, G&& g)

Definition
----------

The function works as defined by the Haskel Function Composition: (.) :: (b -> c) -> (a -> b) -> a -> c 
This function only works in C++14


Parameters
----------
x
Value which is plugged into to previous user defined functions

f(x): first function
g(x): second function



Return value
------------

Function composition of x based on two functions given.  f(g(x)).

Tutorial
--------

1) Define a function f(x) and another function g(x)
2) Enter value for x

 

#include <functional>
#include <iostream>
#include <vector>
#include <string>
#include <math.h>


using namespace functionalibrary;


int f(int x) { return x + 1; }
int g(int x) { return x * 2; }
int h(int x) { return x - 1; }

int main () {
  
  
  std::cout << compose(f, g)(3) << "\n";


  return 0;
}

Output:
7

*****************************************************************************************************************


functionalibrary::take

Prototype
----------
template <typename Value, typename Cont>
std::vector<typename Cont::value_type> take(Value v, const Cont& c)

Definition
----------

The function take will select variable v, applied to a list c, returns the prefix of c of length v, or c itself if v > length c
Follows the Haskel take function definition: take :: Int -> [a] -> [a]

Parameters
----------
x
A distinct integer for number of elements in the container

container
Call any std container that uses forward iterators.



Return value
------------

A container with the number of elements given

Tutorial
--------

1) Define a supported container that uses forward iterators (e.g. std::vector, std::list).
2) Give the number of elemets you want in the new container

 
#include <functional>
#include <iostream>
#include <vector>
#include <string>
#include <math.h>


using namespace functionalibrary;

int main () {
  
  	std::vector<int> sample = {1,2,3,4,5};
	for( auto x : sample) std::cout << x << " ";

	take(3, sample);

	std::cout<< std::endl;

	std::string sample2 = ("Hello World!");
	std::cout << sample2 << " ";

	take(5, sample2);

 	return 0;
}

Output:
1 2 3 4 5
123

Hello World! 
Hello


Complexity
----------

Linear in the distance between first and last iterators.

Data Races
----------

The elements in the range [first,last) are accessed (each element is accessed exactly once).

*****************************************************************************************************************


functionalibrary::takewhile

Prototype
----------
template <typename Predicate, typename Cont>
std::vector<typename Cont::value_type> takeWhile(Predicate good, const Cont& c) 

Definition
----------

The function takewhile applied to a predicate p and a list c, returns the longest prefix (possibly empty) 
of c elements that satisfies the predicate.

Follows the Haskel takewhile function definition: takeWhile :: (a -> Bool) -> [a] -> [a]

Parameters
----------
pred
Unary function that accepts an element in the range as argument, and returns a value convertible to bool. The value returned indicates whether the element is to be removed (if true, it is removed).
The function shall not modify its argument.  This can either be a function pointer or a function object.

container
Call any std container that uses forward iterators.



Return value
------------

A container with the elements as defined by the predicate

Tutorial
--------

1) Define a supported container that uses forward iterators (e.g. std::vector, std::list).
2) Provide a predicate function to apply to the container

 
#include <functional>
#include <iostream>
#include <vector>
#include <string>
#include <math.h>


using namespace functionalibrary;

int main () {
  
  	std::vector<int>sample3 = {1,2,3,4,5,1,2,3,4};

	for( auto x : sample3) std::cout << x << " ";
	
	takeWhile([](int value){ return value < 4;}, sample3);

 	return 0;
}

Output:
1 2 3 4 5 1 2 3 4 
123

Complexity
----------

Linear in the distance between first and last iterators.

Data Races
----------

The elements in the range [first,last) are accessed (each element is accessed exactly once).

*****************************************************************************************************************


functionalibrary::drop

Prototype
----------
template <typename Value, typename Cont>
std::vector<typename Cont::value_type> drop(Value v, const Cont& c)

Definition
----------

The function drop will discard v elements of container c returns the suffix of c after the first v elements,
or [] if v > length c:

Follows the Haskel drop function definition: take :: Int -> [a] -> [a]

Parameters
----------
x
A distinct integer for number of elements in the container

container
Call any std container that uses forward iterators.



Return value
------------

A container with the elements remaining after the given number of elements were removed

Tutorial
--------

1) Define a supported container that uses forward iterators (e.g. std::vector, std::list).
2) Give the number of elemets you want in the new container

 
#include <functional>
#include <iostream>
#include <vector>
#include <string>
#include <math.h>


using namespace functionalibrary;

int main () {
  
  	std::vector<int> sample = {1,2,3,4,5};
	for( auto x : sample) std::cout << x << " ";

	drop(3, sample);

	std::cout<< std::endl;

	std::string sample2 = ("Hello World!");
	std::cout << sample2 << " ";

	drop(6, sample2);

 	return 0;
}

Output:
1 2 3 4 5
45

Hello World! 
World!


Complexity
----------

Linear in the distance between first and last iterators.

Data Races
----------

The elements in the range [first,last) are accessed (each element is accessed exactly once).

*****************************************************************************************************************


functionalibrary::dropwhile

Prototype
----------
template <typename Predicate, typename Cont>
std::vector<typename Cont::value_type> dropWhile(Predicate bad, const Cont& c)

Definition
----------

The function dropwhile applied to a predicate bad and a list c, returns the suffix remaining after predicate bad in the container c

Follows the Haskel takewhile function definition: dropWhile :: (a -> Bool) -> [a] -> [a]

Parameters
----------
pred
Unary function that accepts an element in the range as argument, and returns a value convertible to bool. The value returned indicates whether the element is to be removed (if true, it is removed).
The function shall not modify its argument.  This can either be a function pointer or a function object.

container
Call any std container that uses forward iterators.



Return value
------------

A container with the elements as defined by the predicate

Tutorial
--------

1) Define a supported container that uses forward iterators (e.g. std::vector, std::list).
2) Provide a predicate function to apply to the container

 
#include <functional>
#include <iostream>
#include <vector>
#include <string>
#include <math.h>


using namespace functionalibrary;

int main () {
  
 	std::vector<int>sample4 = {1,2,3,4,5,1,2,3,4};

	for( auto x : sample4) std::cout << x << " ";
	
	dropWhile([](int value){ return value < 3;}, sample3);

 	return 0;
}

Output:
1 2 3 4 5 1 2 3 4 
3451234

Complexity
----------

Linear in the distance between first and last iterators.

Data Races
----------

The elements in the range [first,last) are accessed (each element is accessed exactly once).

*****************************************************************************************************************


